<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Palaeographical Definitions</title>
    <link rel="shortcut icon" href="#">
    <link rel="stylesheet" href="./node_modules/bulma/css/bulma.min.css">
    <link rel="stylesheet" href="./node_modules/font-awesome5/css/fontawesome-all.min.css"/>

    <script src="./node_modules/vue/dist/vue.global.js"></script>
    <script src="utils.js"></script>
    <script type="module">
      // TODO: relative import
      // TODO: modularise use of octokit, create a wrapper
      // TODO: don't import it globally.
      import { Octokit, App } from "https://cdn.skypack.dev/octokit@2.0.14";
      window.Octokit = Octokit
    </script>    
    <link rel="stylesheet" href="./assets/main.css">
  </head>
  <body>
    <section id="definitions" class="section full-width">
      <div :class="['notification', 'is-'+lastMessage.level, 'is-light']">
        {{ lastMessage.content }}
      </div>
      <div class="tabs is-medium is-boxed">
        <ul>
          <li v-for="tab in tabs" :class="{'is-active': selection.tab == tab.key}">
            <a :href="`${tab.key}.html${queryString}`">
              <template v-if="!canSave && tab.key == 'settings'"><i class="fas fa-exclamation-triangle"></i>&nbsp;</template>
              {{ tab.title }}
              &nbsp;
              <button v-if="selection.tab == tab.key" @click.prevent.stop="saveDefinitions()" class="button is-primary" :disabled="!canSave">Save</button>
            </a>            
          </li>
        </ul>
        <a href="https://github.com/kingsdigitallab/crossreads/issues" target="_blank" class="icon-text">
          <span class="icon"><i class="fas fa-bug"></i></span>
          <span>Issues</span>
        </a>
      </div>
      <div class="container is-fluid">

        <div class="tabs is-boxed">
          <ul>
            <li v-for="tab in innerTabs" :class="{'is-active': selection.innerTab == tab.key}">
              <a @click.prevent.stop="selection.innerTab = tab.key">
                {{ tab.title }}
              </a>
            </li>
          </ul>
        </div>

        <template v-if="selection.innerTab == 'ac'">

          <div class="field is-grouped is-horizontal definitions-controls">
            <p class="control">
              <label class="label">Script</label>
              <div class="select">
                <select v-model="selection.script">
                  <option v-for="(scriptName, scriptSlug) in definitions.scripts" :value="scriptSlug">{{ scriptName }}</option>
                </select>
              </div>
            </p>
            <p class="control">
              <input v-model="selection.scriptName" class="input" type="text">
            </p>
            <p class="control">
              <button @click="onCreateScript()" class="button">Create</button>
            </p>
            <p class="control">
              <button @click="onRenameScript()" class="button">Rename</button>
            </p>
            <p class="control">
              <button @click="onDeleteScript()" class="button">Delete</button>
            </p>
          </div>  

          <div v-if="selection.innerTab == 'ac'" class="scrollable-table-wrapper">
            <table class="table table-def table-ac is-striped is-narrow is-hoverable is-fullwidth-no is-bordered">
              <thead>
                <tr>
                  <th></th>
                  <th>
                    <input v-model="newItems.allograph" type="text" class="input" @keyup.enter="onAddItem('allograph')">
                    <!-- <span v-model="newItems.allograph" class="number-input" role="textbox" contenteditable class="input"></span> -->
                    <button @click="onAddItem('allograph')" class="button is-small">Add</button>
                  </th>
                  <th v-for="(allo, alloSlug) in filteredAllographs">
                    {{ allo.character }}
                    <button @click="onRemoveAllograph(alloSlug)" class="button is-small btn-remove is-warning" title="remove"><i class="fas fa-trash"></i></button>
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>
                    <input v-model="newItems.component" type="text" class="input" @keyup.enter="onAddItem('component')">
                    <button @click="onAddItem('component')" class="button is-small">Add</button>
                  </th>
                  <td :colspan="Object.keys(filteredAllographs).length + 1" class="add-cell"></td>
                </tr>
                <tr v-for="(component, componentSlug) in filteredComponents">
                  <th>
                    {{ component.name }}
                    <button @click="onRemoveComponent(componentSlug)" class="button is-small btn-remove is-warning" title="remove"><i class="fas fa-trash"></i></button>
                  </th>
                  <td class="add-cell"></td>
                  <template v-for="allo in filteredAllographs">
                    <td @click.stop.prevent="onClickAllographComponent(allo, componentSlug)">
                      <span v-if="allo.components.includes(componentSlug)" class="checked">✔</span>
                    </td>
                  </template>
                </tr>
              </tbody>
            </table>
          </div>  
        </template>

        <div v-if="selection.innerTab == 'cf'" class="scrollable-table-wrapper">
          <table class="table table-def table-cf is-striped is-narrow is-hoverable is-fullwidth is-bordered">
            <thead>
              <tr>
                <th></th>
                <th>
                  <input v-model="newItems.feature" type="text" class="input" @keyup.enter="onAddItem('feature')">
                  <button @click="onAddItem('feature')" class="button is-small">Add</button>
                </th>
                <th v-for="(feature, featureSlug) in filteredFeatures">
                  <span @keydown.enter="$event.target.blur()" @blur="onRenameFeature($event, featureSlug)" role="textbox" contenteditable class="input-on-hover">{{ feature }}</span>
                  <button @click="onRemoveFeature(featureSlug)" class="button is-small btn-remove is-warning" title="remove"><i class="fas fa-trash"></i></button>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th>
                  <input v-model="newItems.component" type="text" class="input" @keyup.enter="onAddItem('component')">
                  <button @click="onAddItem('component')" class="button is-small">Add</button>
                </th>
                <td :colspan="Object.keys(filteredFeatures).length + 1" class="add-cell"></td>
              </tr>
              <tr v-for="(component, componentSlug) in filteredComponents">
                <th>
                  <!-- <span class="item-name">{{ component.name }}</span> -->
                  <!-- <input @blur="onRenameComponent($event, component)" :value="component.name" type="text" class="input-rename input"> -->
                  <span @keydown.enter="$event.target.blur()" @blur="onRenameComponent($event, component)" role="textbox" contenteditable class="input-on-hover">{{ component.name }}</span>
                  <button @click="onRemoveComponent(componentSlug)" class="button is-small btn-remove is-warning" title="remove"><i class="fas fa-trash"></i></button>
                </th>
                <td class="add-cell"></td>
                <td v-for="(feature, featureSlug) in filteredFeatures" @click.stop.prevent="onClickComponentFeature(component, featureSlug)">
                  <span v-if="component.features.includes(featureSlug)" class="checked">✔</span>
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <template v-if="false">
          <hr>

          <form class="control">
            <label class="label">Archetype homepage URL</label>
            <div class="control">
              <input class="input" type="text" name="archetype_api" :value="archetypeUri">
            </div>
            <div class="control">
              <button @click.prevent.stop="onImportDefinitions()" class="button" type="submit" name="action" value="export-definitions">Import definitions</button>
            </div>
            <div class="control">
              <button @click.prevent.stop="onShortenCollection()" class="button" type="submit" name="action" value="shorten-collection">Shorten collection</button>
            </div>
          </form>
          <textarea style="width:100%; height: 15em;">
            {{ definitions }}
          </textarea>
        </template>
      </div>
    </section>
    <script defer>
      const { createApp } = Vue

      // const componentFeatureUri = '/digipal/api/componentfeature/'
      const componentUri = '/digipal/api/component/?@select=name,*componentfeature_set,feature'
      const allographUri = '/digipal/api/allograph/?@select=*script_set,*allograph_components,name,character,*component'
      const collectionUri = './data/dts/api/collections-2023-01.json'
      const definitionsPath = 'app/data/pal/definitions-digipal.json'

      createApp({
        data() {
          return {
            archetypeUri: '//digipal.eu',
            definitions: {'k1': 'v1'},
            definitionsSha: null,
            selection: {
              script: '',
              scriptName: '',
              tab: 'definitions',
              innerTab: 'ac',
              gtoken: window.localStorage.getItem('gtoken') || '',
            },
            newItems: {
              allograph: '',
              component: '',
              feature: '',
            },
            queryString: '',
            messages: [],
          }
        },
        computed: {
          tabs: () => utils.tabs(),
          innerTabs() {
            return [
              {title: 'Allographs x Components', key: 'ac'},
              {title: 'Components x Features', key: 'cf'},
            ]
          },
          canSave() {
            return !!this.selection.gtoken
          },
          filteredAllographs() {
            return this.getFilteredDefinitions('allographs', (a) => a.character)
          },
          filteredComponents() {
            return this.getFilteredDefinitions('components', (a) => a.name)
          },
          filteredFeatures() {
            return this.getFilteredDefinitions('features', (a) => a)
          },
        },
        mounted() {
          // so we are sure all js modules have been loaded
          window.addEventListener("load", (event) => {
            this.loadDefinitions()
          });
        },
        watch: {
          'selection.script'() {
            this.setScriptName()
          }
        },
        methods: {
          getFilteredDefinitions(collectionName, getNameFromItem) {
            let ret = {}
            let items = this.definitions[collectionName]
            if (items) {
              function sortFunction(a, b) {
                a = getNameFromItem(items[a])
                b = getNameFromItem(items[b])
                return a === b ? 0 : (a > b ? 1 : -1)
              }
              
              for (let k of Object.keys(items).sort(sortFunction)) {
                let item = items[k]
                if (collectionName != 'allographs' || this.selection.script === item.script) {
                  ret[k] = item
                }
              }
            }
            return ret
          },
          onRenameFeature(event, featureSlug) {
            // TODO: error management: value already taken
            console.log('renamed')
            // let value = event.target.value.trim()
            let value = event.target.textContent.trim()
            if (value.length) {
              this.definitions.features[featureSlug] = value
            } else {
              event.target.textContent = this.definitions.features[featureSlug]
            }
          },
          onRenameComponent(event, component) {
            // TODO: error management: value already taken
            let value = event.target.textContent.trim()
            if (value.length) {
              component.name = value
            } else {
              event.target.textContent = component.name
            }
          },
          onRemoveAllograph(allographSlug) {
            delete this.definitions.allographs[allographSlug]
          },
          onRemoveComponent(componentSlug) {
            delete this.definitions.components[componentSlug]
            // TODO: delete component in the allographs?
          },
          onRemoveFeature(featureSlug) {
            delete this.definitions.features[featureSlug]
            // TODO: delete feature in the components?
          },
          onAddItem(itemType) {
            let name = this.newItems[itemType]
            name = name.trim()
            if (name.length < 1) return;

            let slug = name
            if (itemType != 'allograph') {
              slug = utils.slugify(name)
            } else {
              slug = `${slug}-${this.selection.script}`
            }

            let item = this.definitions[itemType+'s'][slug]

            if (itemType == 'allograph') {
              if (!(item && item.script == this.selection.script)) {
                this.definitions.allographs[slug] = {
                  script: this.selection.script,
                  character: name,
                  components: []
                }
              }
            } else {
              if (!item) {
                if (itemType == 'component') {
                  this.definitions.components[slug] = {
                    name: name,
                    features: []
                  }
                }
                if (itemType == 'feature') {
                  this.definitions.features[slug] = name
                }
              }
            }

            this.newItems[itemType] = ''
          },
          onCreateScript() {
            // TODO: error management
            let name = this.selection.scriptName
            let slug = utils.slugify(name)
            this.definitions.scripts[slug] = name
            this.selection.script = slug
          },
          onRenameScript() {
            // TODO: error management
            this.definitions.scripts[this.selection.script] = this.selection.scriptName
            // TODO: change slug???
          },
          onDeleteScript() {
            // TODO: error management
            delete this.definitions.scripts[this.selection.script]
            this.selectFirstScript()
            // TODO: delete allographs?
          },
          selectFirstScript() {
            this.selection.script = Object.keys(this.definitions.scripts)[0]
          },
          setScriptName() {
            this.selection.scriptName = this.definitions.scripts[this.selection.script]
          },
          onClickAllographComponent(allo, componentSlug) {
            if (allo.components.includes(componentSlug)) {
              allo.components = allo.components.filter((c) => c != componentSlug)
            } else {
              allo.components.push(componentSlug)
            }
          },
          onClickComponentFeature(component, featureSlug) {
            if (component.features.includes(featureSlug)) {
              component.features = component.features.filter((f) => f != featureSlug)
            } else {
              component.features.push(featureSlug)
            }
          },
          getOctokit() {
            // TODO: create wrapper class around Octokit
            // TODO: cache this
            let ret = null
            if (this.selection.gtoken) {
              ret = new Octokit({
                auth: this.selection.gtoken
              })
            }
            return ret
          },
          async loadDefinitions() {
            // // TODO: temporarily locals
            let res = await utils.readGithubJsonFile(definitionsPath, this.getOctokit())
            // let res = await utils.readGithubJsonFile('../' + definitionsPath)
            if (res) {
              this.definitions = res.data
              this.definitionsSha = res.sha
              console.log(this.definitions)
              this.selectFirstScript()
            }
            this.setAddressBarFromSelection()
          },
          async saveDefinitions() {
            // TODO: sha
            this.definitionsSha = await utils.updateGithubJsonFile(definitionsPath, this.definitions, this.getOctokit(), this.definitionsSha)
          },
          onShortenCollection(e) {
            const self = this;
            let uri = collectionUri;

            // TODO: remove hard-coded values
            const toKeep = new RegExp('ISic0000(01|07|31|46|79)$')

            fetch(uri).then(r => r.json()).then(res => {
              ret = res

              ret.member = ret.member.filter(
                m => 
                !!(m && m.title.match(toKeep))
              )

              ret.totalItems = ret.member.length
              ret['dts:totalChildren'] = ret.member.length

              self.definitions = ret
            })
            
          },
          onImportDefinitions(e) {
            const self = this;
            let uri = self.archetypeUri + componentUri;

            fetch(uri).then(r => r.json()).then(res => {
              let features = {};
              let components = {};
              for (let c of res.results) {
                components[this.slugify(c.name)] = {
                  name: c.name,
                  features: c.componentfeature_set.map(cf => this.slugify(cf.feature))
                }
                for (cf of c.componentfeature_set) {
                  features[this.slugify(cf.feature)] = cf.feature
                }
              }

              uri = self.archetypeUri + allographUri;
              fetch(uri).then(r => r.json()).then(res => {
                const allographs = {};
                
                for (let a of res.results) {
                  let allograph_name = a.character

                  let allograph = {
                    script: 'SCRIPT',
                    character: a.character,
                    components: a.allograph_components.map(c =>
                      this.slugify(c.component.name)
                    )
                  }
                  allographs[this.slugify(allograph_name, true)] = allograph
                }

                let ret = {
                  'context': self.archetypeUri,
                  'version': '0.1',
                  'updated': new Date().toISOString(),
                  'scripts': {},
                  'features': features,
                  'components': components,
                  'allographs': allographs,
                };
                self.definitions = ret;
              })
            })
          },
          slugify(text, preserveCase=false) {
            // stolen from https://gist.github.com/codeguy/6684588?permalink_comment_id=4176055#gistcomment-4176055
            ret = text
              .toString()                           // Cast to string (optional)
              .normalize('NFKD')            // The normalize() using NFKD method returns the Unicode Normalization Form of a given string.

            if (!preserveCase)
              ret = ret
              .toLowerCase()                  // Convert the string to lowercase letters

            ret = ret
              .trim()                                  // Remove whitespace from both sides of a string (optional)
              .replace(/\s+/g, '-')            // Replace spaces with -
              .replace(/[^\w\-]+/g, '')     // Remove all non-word chars
              .replace(/\-\-+/g, '-');        // Replace multiple - with single -
            
            return ret
          },
          setAddressBarFromSelection() {
            let searchParams = new URLSearchParams(window.location.search);

            let qs = `?${searchParams.toString()}`
            this.queryString = decodeURIComponent(qs)
          },
          lastMessage() {
            let ret = {
              content: '',
              level: 'info',
              created: new Date()
            }
            if (this.messages.length) {
              ret = this.messages[this.messages.length - 1]
            }
            return ret
          },
        }
      }).mount('#definitions')
    </script>
  </body>
</html>