<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Annotator</title>
    <link rel="shortcut icon" href="#">
    <link rel="stylesheet" href="./node_modules/bulma/css/bulma.min.css">
    <link rel="stylesheet" href="./node_modules/font-awesome5/css/fontawesome-all.min.css"/>

    <script src="./node_modules/openseadragon/build/openseadragon/openseadragon.min.js"></script>
    <link rel="stylesheet" href="./node_modules/@recogito/annotorious-openseadragon/dist/annotorious.min.css">
    <script src="./node_modules/@recogito/annotorious-openseadragon/dist/openseadragon-annotorious.min.js"></script>

    <!-- importmap shim for Firefox -->
    <script src="./node_modules/vue/dist/vue.global.js"></script>
    <link rel="stylesheet" href="./assets/main.css">

    <script src="utils.js"></script>
    <script type="module">
      // TODO: relative import
      import { Octokit } from "https://cdn.skypack.dev/@octokit/core";
      // import { Octokit } from "./node_modules/@octokit/core/dist-web/index.js";
      window.Octokit = Octokit
    </script>    

  </head>
  <body>
    <section class="section" id="annotator">
      <!-- <button @click="loadAnnotationsFromSession()">Load</button>
      <button @click="saveAnnotationsToSession()">Save</button> -->
      <div class="container">
        <h1 class="title">
          Annotator
          <span class="side-links">
            <a href="./definitions.html">definitions</a> | 
            <a href="./settings.html">settings</a>
          </span>
        </h1>
        <div class="columns is-3">
          <div class="column">
            <div class="panel panel-objects">
              <p class="panel-heading">
                Objects
              </p>
              <div class="panel-block">
                <p class="control has-icons-left">
                  <input class="input" type="text" placeholder="Search" v-model="searchPhrase">
                  <span class="icon is-left">
                    <i class="fas fa-search" aria-hidden="true"></i>
                  </span>
                </p>
              </div>
              <div class="panel-block">
                <ul class="list-selectable">
                  <a v-for="(obj2, idx) in filteredObjects" href="#" @click.prevent="onSelectObject(obj2)">
                    <li :class="{'selected': obj2 == object}">
                      {{ obj2.description }}
                    </li>
                  </a>
                </ul>
                <!-- <div class="select list-objects">
                  <select v-model="object" size="10">
                    <option v-for="(obj2, idx) in filteredObjects">{{ obj2.name }}</option>
                  </select>
                </div> -->
              </div>
              <p class="panel-heading">
                Images
              </p>
              <div class="panel-block">
                <ul class="list-selectable">
                  <a v-for="(img, idx) in filteredImages" href="#" @click.prevent="onSelectImage(img)">
                    <li :class="{'selected': img == image}">
                      {{ img.uri }}
                    </li>
                  </a>
                </ul>
              </div>
            </div>
          </div>
          <div class="column is-6">
            <div class="panel">
              <p class="panel-heading">
                Image
                <span class="side-links">
                  <button @click="onClickSave()" class="button is-small is-default">Save</button>
                </span>
              </p>
              <div class="panel-block">
                <div id="image-viewer" style="width: 800px; height: 300px;"></div>
              </div>
              <p class="panel-heading">
                Transcription
              </p>
              <div class="panel-block transcription">
                <p v-html="text">
                </p>
              </div>
            </div>
          </div>
          <div class="column is-3">
            <div class="panel">
              <p class="panel-heading">
                Annotation
                <span v-if="isAnnotationSelected">(Selected)</span>
              </p>
              <div class="panel-block">
                <dl class="description">
                  <dt>Allograph</dt> 
                  <dd>
                    <span v-if="!(description.allograph in definitions.allographs)">{{description.allograph}}</span>
                    <div class="select">
                      <select v-model="description.allograph" @change="onChangeAllograph()">
                        <option v-for="(allograph, allographKey) in definitions.allographs" :value="allographKey">{{ allograph.character }} ({{ allograph.script }})</option>
                      </select>
                    </div>
                  </dd>
                  <dt>Components</dt> 
                  <dd><ul class="components-features">
                    <li v-for="component in description.components">
                      <span class="component-name">
                        <template v-if="definitions.components[component[0]]">
                          {{ definitions.components[component[0]].name }}
                        </template>
                        <template v-else>
                          {{ component[0] }}
                        </template>
                      </span>
                      <ul>
                        <li v-for="(isFeaturePresent, featureKey, index) in component[1]">
                          <label :class="{selectable: true, selected: isFeaturePresent}"><input type="checkbox" v-model="component[1][featureKey]" @change="onChangeComponentFeature()">
                            <template v-if="definitions.features[featureKey]"> 
                              {{ definitions.features[featureKey] }}
                            </template>
                            <template v-else>
                              {{ featureKey }}
                            </template>
                          </label>
                        </li>
                      </ul>
                    </li>
                  </ul></dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <script type="module">

      /* TODO: modularise the Vue app:
      . Objects List
      . Images List
      . Image
      . Description
      . Text

      - remove hard-coded values (e.g. paths)
      */ 

      let IMG_PATH_IIIF_ROOT = 'http://localhost:49153/iiif/2/'
      // if defined, the viewer will fetch full image files instead of IIIF tiles
      let IMG_PATH_STATIC_ROOT = './data/2022/'

      // TODO: move this into Vue?
      function loadOpenSeaDragon(vueApp) {
        var viewer = OpenSeadragon({
            id: "image-viewer",
            prefixUrl: './node_modules/openseadragon/build/openseadragon/images/',
            tileSources: {
              type: "image",
              url: "http://localhost:49153/iiif/2/ISic000001.jpg/full/full/0/default.jpg"
            },
            zoomPerClick: 1.0, // disable the zoom on click
        });

        // Initialize the Annotorious plugin
        const config = {
          disableEditor: true,
          allowEmpty: true,
          // disableSelect: true,
          // TODO: js error after select + click outside rect
          // fragmentUnit: 'percent', 
          formatters: vueApp.annotoriousFormatter
        };
        var anno = OpenSeadragon.Annotorious(viewer, config);
        vueApp.anno = anno;
        vueApp.viewer = viewer;

        let eventNames = [
          'createSelection', 'createAnnotation', 'updateAnnotation', 
          'selectAnnotation', 'cancelSelected', 'clickAnnotation', 
          'deleteAnnotation', 'changeSelectionTarget',
          // 'mouseLeaveAnnotation', 'mouseLeaveAnnotation'
        ]
        for (let eventName of eventNames) {
          anno.on(eventName, vueApp[`on${eventName[0].toUpperCase()}${eventName.substring(1)}`]);
        }
        anno.on('open-failed', vueApp.onImageOpenFailed);
        // setAnnotations() is defered by Annotorious until tiles are loaded.
        // So we wait until it's ready to do things based on getAnnotations().
        viewer.addHandler('open', () => {
          // vueApp.updateSignHighlights()
          vueApp.loadAnnotationsFromSession()
        });

      }; 

      const { createApp } = Vue

      createApp({
        data() {
          return {
            // TODO: not reactive
            apis: {
              // collections: 'https://isicily-dts.herokuapp.com/dts/api/collections/',
              collections: './data/dts/api/collections-test.json',
              definitions: './data/pal/definitions-digipal.json',
            },
            objects: [
              {'description': 'Object 1', '@id': 'obj1', 'title': 't1'},
              {'description': 'Object 2', '@id': 'obj2', 'title': 't2'},
              {'description': 'Object 3', '@id': 'obj3', 'title': 't3'},
            ],
            object: null,
            searchPhrase: '',
            images: [],
            image: null,
            text: 'test',
            // annotatedText: {
            //   textId: '',
            //   wordId: '',
            //   signId: '',
            // },
            definitions: {
              features: {
                'f1': 'F 1',
                'f2': 'F 2',
              },
              components: {
                'c1': {
                  name: 'C 1',
                  features: [
                    'f1', 'f2'
                  ]
                },
              },
              allographs: {
                'latin.G': {
                  script: 'Latin',
                  character: 'G',
                  components: ['c1'], 
                },
              }
            },
            description: {
              allograph: 'a',
              components: [
                ['c1', {'f1': false, 'f3': true}],
              ],
              // TODO: aspects
              // TODO: move this out of description, it should be an annotation target; not in ann body 
              textTarget: {
                // TODO: is there a std for this kind of ptr?
                textId: null,
                wordId: null,
                signId: null
              }
            },
            annotation: null,
            cache: {
              isDescriptionLoading: false,
              allographLast: '123',
              // TODO: not reactive?
              store: {
                imagesAnnotations: {
                  'objectkey.imagekey': {
                    // annotations for that object-image
                  }
                }
              }
            },
            selection: {
              gtoken: window.localStorage.getItem('gtoken') || '',
            },
          }
        },
        mounted() {
          // TODO: chain load (from objects, to image, ...) 
          // instead of loading all here.in parallel
          loadOpenSeaDragon(this)
          this.loadObjects()
          this.loadDefinitions()
        },
        watch: {
          object(val, valOld) {
            this.fetchObjectXML()
          },
        },
        computed: {
          filteredObjects() {
            return this.objects.filter(o => o.description.toLowerCase().includes(this.searchPhrase.toLowerCase()))
          },
          filteredImages() {
            return this.images.filter(i => i.type == 'print')
          },
          isAnnotationSelected() {
            return !!this.annotation
          }
        },
        methods: {
          loadObjects() {
            // Load objects list (this.objects) from DTS collections API 
            fetch(this.apis.collections)
              .then(res => res.json())
              .then(res => {
                // console.log(res)
                this.objects = []
                for (let m of res.member) {
                  if (m) {
                    this.objects.push({
                      '@id': m['@id'],
                      title: m.title,
                      description: m.description,
                      "dts:download": m['dts:download']
                    })
                  }
                }
                if (this.objects.length) {
                  this.object = this.objects[0]
                } else {
                  this.object = null
                }
              })
          },
          loadDefinitions() {
            fetch(this.apis.definitions)
              .then(res => res.json())
              .then(res => {
                this.definitions = res
                this.updateDescriptionFromAllograph()
              })
          },
          fetchObjectXML() {
            // fetch the TEI XML from DTS API for the selected object (this.object)
            if (this.object) {
              const uri = this.object["dts:download"]
              const self = this
              fetch(uri)
                .then(res => res.text())
                .then(res => new window.DOMParser().parseFromString(res, 'text/xml'))
                .then(xml => {
                  // self.tei = res
                  // Only to ease debugging
                  // window.tei = res

                  this.setImagesFromObjectXML(xml)
                  this.setTextFromObjectXML(xml)
                })
            }
          },
          setImagesFromObjectXML(xml) {
            // get all the tei:graphic -> image locations
            this.images = []
            let it = xml.evaluate('//tei:graphic', xml, this.getURIFromXMLPrefix, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null)
            while (true) {
              let node = it.iterateNext()
              if (!node) break
              // TODO: less assumption about encoding, make it more robust 
              this.images.push({
                description: node.children[0].textContent,
                uri: node.attributes['url'].value,
                type: node.attributes['n'].value, // screen|print
                surface: node.parentElement.attributes.type.value // front
              })
            }
            let filteredImages = this.filteredImages
            this.onSelectImage(filteredImages ? filteredImages[0] : null)
          },
          setTextFromObjectXML(xml) {
            // xml (TEI) -> this.text (XHTML)
            fetch('./data/tei2html.xslt')
              .then(res => res.text())
              .then(res => new window.DOMParser().parseFromString(res, 'text/xml'))
              .then(res => {
                let processor = new XSLTProcessor()
                processor.importStylesheet(res)
                let doc = processor.transformToFragment(xml, document)
                // set data-idx to each span.sign, relative to its parent span.word
                for (let word of doc.querySelectorAll('.word')) {
                  let signIdx = 0
                  for (let sign of word.querySelectorAll('.sign')) {
                    sign.attributes.getNamedItem('data-idx').value = signIdx++
                  }
                }
                // to string
                this.text = new XMLSerializer().serializeToString(doc)
                // console.log(this.text)
                // attach events to each sign
                Vue.nextTick(() => {
                  for (let sign of document.querySelectorAll('.sign')) {
                    sign.addEventListener('click', (e) => this.onClickSign(sign));
                    sign.addEventListener('mouseenter', (e) => this.onMouseEnterSign(sign));
                    sign.addEventListener('mouseleave', (e) => this.onMouseLeaveSign(sign));
                  }
                  // console.log('setTextFromObjectXML:updateSignHighlights')
                  this.updateSignHighlights()
                })
              })
          },
          onClickSign(sign) {
            // console.log('Click sign')
            let selectedAnnotation = this.anno.getSelected()
            let signAnnotation = this.getAnnotationFromSign(sign)
            let annotationSign = this.getSignFromAnnotation()
            if (sign == annotationSign) {
              // unbind sign from selected annotation
              this.description.textTarget = null
              this.updateSelectedAnnotationFromDescription()
            } else if (selectedAnnotation && !signAnnotation && !annotationSign) {
              // bind sign to selected annotation
              this.description.textTarget = this.getTextTargetFromSign(sign)
              this.updateSelectedAnnotationFromDescription()
              signAnnotation = selectedAnnotation
            }
            this.selectAnnotation(signAnnotation)
          },
          getAnnotationFromSign(sign) {
            let ret = null
            for (let annotation of this.anno.getAnnotations()) {
              let asign = this.getSignFromAnnotation(annotation)
              if (sign == asign) {
                ret = annotation
                break
              }
            }

            return ret
          },
          getTextTargetFromSign(sign) {
            let word = sign.closest('.word')
            return {
              textId: null,
              wordId: word.attributes.getNamedItem('id').value,
              signId: sign.attributes.getNamedItem('data-idx').value
            }
          },
          updateSignHighlights() {
            // TODO: optimise... calling this each time something change is ineffective
            for (let sign of document.querySelectorAll('.sign.selected')) {
              sign.classList.remove('selected')
            }
            for (let sign of document.querySelectorAll('.sign.bound')) {
              sign.classList.remove('bound')
            }
            // console.log(`updateSignHighlights: ${this.anno.getAnnotations().length} annotations`)
            for (let annotation of this.anno.getAnnotations()) {
              let sign = this.getSignFromAnnotation(annotation)
              if (sign) {
                sign.classList.add('bound')
                if (this?.annotation?.id == annotation.id) {
                  sign.classList.add('selected')
                }
              }
            }
          },
          getSignFromAnnotation(annotation=null) {
            let ret = null
            annotation = annotation || this.annotation
            if (annotation?.body?.length) {
              let description = JSON.parse(annotation.body[0].value)
              if (description?.textTarget?.signId) {
                let word = document.querySelector(`.word[id="${description?.textTarget?.wordId}"]`)
                if (word) {
                  ret = word.querySelector(`span[data-idx="${description?.textTarget?.signId}"]`)
                }
              }
            }
            return ret
          },
          onMouseEnterSign(sign) {
            // console.log('Mousenter sign')
          },
          onMouseLeaveSign(sign) {
            // console.log('Mouseleave sign')
          },
          onChangeAllograph() {
            this.updateDescriptionFromAllograph()
            this.updateSelectedAnnotationFromDescription()
          },
          onChangeComponentFeature() {
            this.updateSelectedAnnotationFromDescription()
          },
          updateSelectedAnnotationFromDescription() {
            let annotation = this.anno.getSelected()
            if (annotation) {
              annotation.body[0].value = JSON.stringify(this.description)
              this.anno.updateSelected(annotation)
              this.saveAnnotationsToSession()
            }
          },
          updateDescriptionFromAllograph() {
            let description = this.description
            if (1 || description.allograph != this.cache.allographLast) {
              if (this.definitions.allographs[description.allograph]) {
                this.description.components = []
                for (let componentKey of this.definitions.allographs[description.allograph].components) {
                  let features = {}
                  for (let featureKey of this.definitions.components[componentKey].features) {
                    features[featureKey] = false
                  }
                  // console.log(features)
                  this.description.components.push([componentKey, features])
                }
                this.cache.allographLast = description.allograph
              }
            }
          },
          // Events - Annotorious
          async onCreateSelection(selection) {
            // console.log('EVENT onCreateSelection')

            // selection.motivation = 'describing'
            selection.body = [{
              type: 'TextualBody',
              purpose: 'describing',
              format: 'application/json',
              value: JSON.stringify(this.description)
            }];

            // use this instead of updateSelected & saveSelected()
            // because
            // 1) getAnnotations() wouldn't have teh new body yet
            // 2) user can't draw another box, they have to deselect first
            // This will update the selection, 
            // then save it as an annotation (i.e. type=annotation)
            // then trigger createAnnotation event
            await this.anno.updateSelected(selection, true);
          },
          onCreateAnnotation(annotation, overrideId) {
            console.log('EVENT onCreateAnnotation')
            this.saveAnnotationsToSession()
            this.anno.selectAnnotation(annotation)
          },
          onMouseEnterAnnotation(annotation, element) {
            // console.log('EVENT onMouseEnterAnnotation')
          },
          onMouseLeaveAnnotation(annotation, element) {
            // console.log('EVENT onMouseLeaveAnnotation')
            // console.log(annotation)
          },
          onChangeSelectionTarget() {
            console.log('EVENT onChangeSelectionTarget')
            // wont work... bc the annotation is only modified after unselecting it and that trigger update -> save
            this.saveAnnotationsToSession()
          },
          onUpdateAnnotation() {
            console.log('EVENT onUpdateAnnotation')
            this.saveAnnotationsToSession()
            // this.saveAnnotationsToSession()
          },
          selectAnnotation(annotation) {
            this.anno.selectAnnotation(annotation)
            this.onSelectAnnotation(annotation)
            return annotation
          },
          onSelectAnnotation(annotation) {
            console.log('EVENT onSelectAnnotation')
            if (annotation) {
              this.description = JSON.parse(annotation.body[0].value)
              // This call sometimes returns undefined after a selectAnnotation(annotation)!
              // this.annotation = this.anno.getSelected()
              this.annotation = annotation
            } else {
              this.onCancelSelected()
            }
            this.updateSignHighlights()
          },
          onCancelSelected(selection) {
            // at this point this.anno.getSelected() still returns an annotation!
            this.annotation = null
            delete this.description.textTarget
            this.updateSignHighlights()
            console.log('EVENT onCancelSelected')
          },
          onDeleteAnnotation() {
            console.log('EVENT onDeleteAnnotation')
            this.saveAnnotationsToSession()
          },
          onClickAnnotation() {
            console.log('EVENT onClickAnnotation')
            // this.saveAnnotationsToSession()
          },
          // Events - Selection
          onSelectObject(obj) {
            this.object = obj
          },
          onSelectImage(img) {
            this.image = img
            if (img) {
              let options = {}
              if (typeof IMG_PATH_STATIC_ROOT !== 'undefined') {
                options = {
                  type: 'image',
                  // TODO: temporary static call so app works on github pages without IIIF server
                  // http://openseadragon.github.io/examples/tilesource-image/
                  url: `${IMG_PATH_STATIC_ROOT}${this.image.uri}`,
                }
              } else {
                options = {
                  type: 'image',
                  // TODO: doesn't use IIIF tiles!
                  // http://openseadragon.github.io/examples/tilesource-iiif/
                  // url: `${IMG_PATH_IIIF_ROOT}${this.image.uri}/full/full/0/default.jpg`,
                }
                options = [
                  // 'https://libimages1.princeton.edu/loris/pudl0001%2F4609321%2Fs42%2F00000001.jp2/info.json'
                  `${IMG_PATH_IIIF_ROOT}${this.image.uri}/info.json`
                ]
              }
              this.viewer.open(options)
            }
            // now done in the 'open' event to make sure viewer is ready 
            // and anno.getAnnotations() returns something
            // this.loadAnnotationsFromSession()
          },
          // Events - Other
          onImageOpenFailed() {
            // TODO
            console.log('OPEN FAILED')
          },
          // Persistence backend
          saveAnnotationsToSession() {
            if (this.image?.uri) {
              this.cache.store.imagesAnnotations[this.image.uri] = this.anno.getAnnotations()
              window.localStorage.setItem('imagesAnnotations', JSON.stringify(this.cache.store.imagesAnnotations))
              console.log('save annotations')
            }
          },
          onClickSave() {
            // save the image annotations to github
            // TODO: save sha?
            let sha = null
            let filePath = `annotations/${this.object['@id']}/${this.image.uri}.json`.replace(/\W+/g, '-')
            let data = this.anno.getAnnotations()
            utils.updateGithubJsonFile(filePath, data, this.getOctokit(), sha)
          },
          getOctokit() {
            // TODO: create wrapper class around Octokit
            // TODO: cache this
            let ret = null
            if (this.selection.gtoken) {
              ret = new Octokit({
                auth: this.selection.gtoken
              })
            }
            return ret
          },
          loadAnnotationsFromSession() {
            let imagesAnnotations = window.localStorage.getItem('imagesAnnotations')
            if (imagesAnnotations) {
              this.cache.store.imagesAnnotations = JSON.parse(imagesAnnotations)
              let annotations = this.image?.uri ? this.cache.store.imagesAnnotations[this.image.uri] : null
              if (annotations) {
                // !!! this.anno.getAnnotations() just after this will return empty set.
                // Because Annotorious uses a _lazy function that defer if tiles are not yet loaded.
                // https://github.com/recogito/annotorious-openseadragon/blob/3321e003732da612097bb23e440717a2c510bd4d/src/OSDAnnotationLayer.js#L303
                this.anno.setAnnotations(annotations)
                // console.log('loadAnnotationsFromSession:updateSignHgighlights')
                // console.log(annotations.length)
                // console.log(this.anno.getAnnotations().length)
                this.updateSignHighlights()
              } else {
                this.anno.clearAnnotations()
              }
            }
          },
          // Low-level Utilities
          getURIFromXMLPrefix(prefix) {
            const ns = {
              'tei': 'http://www.tei-c.org/ns/1.0',
              'xhtml': 'http://www.w3.org/1999/xhtml',
            };
            return ns[prefix] || null;
          },
          annotoriousFormatter(annotation) {
            // sets 'bound' class to annotation svg 
            // if bound to a sign in the text.
            let ret = ''
            if (this.getSignFromAnnotation(annotation)) {
              ret = 'bound'
            }
            // console.log(`formatter: "${ret}"`)
            return ret
          },
          isTokenMissing() {
            return !this.selection.gtoken
          },
        }
      }).mount('#annotator');
    </script>

  </body>
</html>
