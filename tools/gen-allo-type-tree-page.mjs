/*
This script generates a web page from a long array of variants such as this example:

[
  {
    "variant-name": "type1",
    "allograph": "A",
    "component-features": [
      {
        "component": "crossbar",
        "feature": "straight",
        "inherited-from": "type1"
      }
    ],
    "script": "latin"
  },
  {
    "allograph": "A",
    "component-features": [
      {
        "component": "crossbar",
        "feature": "ascending",
        "inherited-from": "type1.1"
      },
      {
        "component": "crossbar",
        "feature": "straight",
        "inherited-from": "type1"
      }
    ],
    "variant-name": "type1.1",
    "script": "latin"
  },
]

The web page generated by this script should:
* show a tree of scripts > allographs > variant > sub-variant (where type3.4 would be a sub-variant of type3). Note that not all variants have sub-variants
* show the characteristic component-features for each variant 
* be rendered with a single Nunjucks template. All HTML tags should be in the template. The variables in the context.
* not rely on any third-party libraries or frameworks
* use as little javascript as possible
* be web accessible
* have a fully expanded tree on page load
* allow the user to collapse any node

For instance type1.1 would appear under latin > A > type1 > type1.1

Note that the variant name is relative to the allograph and script.
So we can have A type1 and B type 1.

*/

import * as fs from 'node:fs';
import { utils, FILE_PATHS, SETTINGS } from '../app/utils.mjs'
import * as toolbox from './toolbox.mjs'

// Constants for easy editing
const PATH_PREFIX = '../'
// const VARIANT_RULES_JSON_PATH = '../app/data/variant-rules.json';
const TREE_PAGE_PATH = '../app/data/allographs/types/all.html'

function buildTree(variants, definitions) {
  /* Returns a tree of script > allograph > variants > sub-variants.
  Such as this:
  {
    "latin": {
      "A": [
        {
          "variant-name": "type1",
          "allograph": "A",
          "component-features": [
            {
              "component": "crossbar",
              "feature": "straight"
            }
          ],
          "script": "latin",
          "children": [
            {
              "allograph": "A",
              "component-features": [
                {
                  "component": "crossbar",
                  "feature": "ascending"
                },
                {
                  "component": "crossbar",
                  "feature": "straight"
                  "ancestor": "type1"
                }
              ],
              "variant-name": "type1.1",
              "script": "latin",
              "children": []
            }
          ]
        }
      ]
    }
  }
  */
  const ret = {};

  // 1. sort variants by script, allograph and then variant-name
  variants.sort((a, b) => {
    if (a.script !== b.script) {
      return a.script.localeCompare(b.script);
    }
    if (a.allograph !== b.allograph) {
      return a.allograph.localeCompare(b.allograph);
    }
    return a["variant-name"].localeCompare(b["variant-name"]);
  });

  // 2. index all variants by script, allograph and variant-name
  // and nest the variants in the index based on the hierarchy of types in variant-name
  let index = {}
  for (const v of variants) {
    v.children = []
    let key = `${v.script}-${v.allograph}-${v['variant-name']}`
    let parentKey = key.replace(/\.\d+$/, "")
    
    // v.scriptLabel = utils.getLabelFromDefinition(v.script, "scr", definitions)

    if (index[parentKey]) {
      index[parentKey].children.push(v);
      // for each cf in v["component-features"] set 
      // cf["inherited-from"] = value from parent
      // cf["inherited-from"] = v[variant-name] if that component-feature is not found in parent
      for (const cf of v["component-features"]) {  
        cf["inherited-from"] = v["variant-name"];
        cf["label"] = utils.getLabelFromDefinition(`${cf['component']} is ${cf['feature']}`, "cxf", definitions)
        for (const pcf of index[parentKey]["component-features"]) {
          if (pcf.component === cf.component && pcf.feature === cf.feature) {
            cf["inherited-from"] = pcf["inherited-from"]
          }
        }
      }
    } else {
      if (!ret[v.script]) ret[v.script] = {};
      if (!ret[v.script][v.allograph]) ret[v.script][v.allograph] = [];
      ret[v.script][v.allograph].push(v)
      for (const cf of v["component-features"]) {
        cf["inherited-from"] = v["variant-name"]
        cf["label"] = utils.getLabelFromDefinition(`${cf['component']} is ${cf['feature']}`, "cxf", definitions)
      }
    }
    index[key] = v;
  }

  return ret;
}

function loadJsonFile(path) {
  const ret = utils.readJsonFile(PATH_PREFIX + path)
  if (!ret) {
    throw Error(`Can't find the definition file.`)
  }
  return ret
}

function main() {
  const definitions = loadJsonFile(FILE_PATHS.DEFINITIONS)
  const variants = loadJsonFile(FILE_PATHS.VARIANT_RULES)
  const tree = buildTree(variants, definitions)

  let res = toolbox.renderTemplate('allo-type-tree.liquid', {
    tree: tree, 
    scripts: definitions.scripts,
    links: {
      annotatingSiteRoot: SETTINGS.ANNOTATING_SITE_ROOT,
      crossreadsPortalRoot: SETTINGS.CROSSREADS_PORTAL_ROOT,
    }
  })

  fs.writeFileSync(TREE_PAGE_PATH, res);
}

main()
